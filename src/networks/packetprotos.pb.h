// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: packetprotos.proto

#ifndef PROTOBUF_packetprotos_2eproto__INCLUDED
#define PROTOBUF_packetprotos_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 2005000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 2005000 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/unknown_field_set.h>
// @@protoc_insertion_point(includes)

namespace protos {

// Internal implementation detail -- do not call these.
void  protobuf_AddDesc_packetprotos_2eproto();
void protobuf_AssignDesc_packetprotos_2eproto();
void protobuf_ShutdownFile_packetprotos_2eproto();

class vector;
class RenderedObj;
class Event;
class ControlInput;
class GeneralPacket;
class ShipInitPacket;
class ObjsAndEventsPacket;
class ObjsAndEventsReqPacket;
class EventAckPacket;
class ControlInputPacket;

// ===================================================================

class vector : public ::google::protobuf::Message {
 public:
  vector();
  virtual ~vector();

  vector(const vector& from);

  inline vector& operator=(const vector& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const vector& default_instance();

  void Swap(vector* other);

  // implements Message ----------------------------------------------

  vector* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const vector& from);
  void MergeFrom(const vector& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required float x = 1;
  inline bool has_x() const;
  inline void clear_x();
  static const int kXFieldNumber = 1;
  inline float x() const;
  inline void set_x(float value);

  // required float y = 2;
  inline bool has_y() const;
  inline void clear_y();
  static const int kYFieldNumber = 2;
  inline float y() const;
  inline void set_y(float value);

  // required float z = 3;
  inline bool has_z() const;
  inline void clear_z();
  static const int kZFieldNumber = 3;
  inline float z() const;
  inline void set_z(float value);

  // @@protoc_insertion_point(class_scope:protos.vector)
 private:
  inline void set_has_x();
  inline void clear_has_x();
  inline void set_has_y();
  inline void clear_has_y();
  inline void set_has_z();
  inline void clear_has_z();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  float x_;
  float y_;
  float z_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  friend void  protobuf_AddDesc_packetprotos_2eproto();
  friend void protobuf_AssignDesc_packetprotos_2eproto();
  friend void protobuf_ShutdownFile_packetprotos_2eproto();

  void InitAsDefaultInstance();
  static vector* default_instance_;
};
// -------------------------------------------------------------------

class RenderedObj : public ::google::protobuf::Message {
 public:
  RenderedObj();
  virtual ~RenderedObj();

  RenderedObj(const RenderedObj& from);

  inline RenderedObj& operator=(const RenderedObj& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const RenderedObj& default_instance();

  void Swap(RenderedObj* other);

  // implements Message ----------------------------------------------

  RenderedObj* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const RenderedObj& from);
  void MergeFrom(const RenderedObj& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 id = 1;
  inline bool has_id() const;
  inline void clear_id();
  static const int kIdFieldNumber = 1;
  inline ::google::protobuf::uint32 id() const;
  inline void set_id(::google::protobuf::uint32 value);

  // required uint32 mass = 2;
  inline bool has_mass() const;
  inline void clear_mass();
  static const int kMassFieldNumber = 2;
  inline ::google::protobuf::uint32 mass() const;
  inline void set_mass(::google::protobuf::uint32 value);

  // required uint32 type = 3;
  inline bool has_type() const;
  inline void clear_type();
  static const int kTypeFieldNumber = 3;
  inline ::google::protobuf::uint32 type() const;
  inline void set_type(::google::protobuf::uint32 value);

  // required float size = 4;
  inline bool has_size() const;
  inline void clear_size();
  static const int kSizeFieldNumber = 4;
  inline float size() const;
  inline void set_size(float value);

  // required float cur_tolerance = 5;
  inline bool has_cur_tolerance() const;
  inline void clear_cur_tolerance();
  static const int kCurToleranceFieldNumber = 5;
  inline float cur_tolerance() const;
  inline void set_cur_tolerance(float value);

  // required float max_tolerance = 6;
  inline bool has_max_tolerance() const;
  inline void clear_max_tolerance();
  static const int kMaxToleranceFieldNumber = 6;
  inline float max_tolerance() const;
  inline void set_max_tolerance(float value);

  // required uint32 is_destroyed = 7;
  inline bool has_is_destroyed() const;
  inline void clear_is_destroyed();
  static const int kIsDestroyedFieldNumber = 7;
  inline ::google::protobuf::uint32 is_destroyed() const;
  inline void set_is_destroyed(::google::protobuf::uint32 value);

  // required .protos.vector pos = 8;
  inline bool has_pos() const;
  inline void clear_pos();
  static const int kPosFieldNumber = 8;
  inline const ::protos::vector& pos() const;
  inline ::protos::vector* mutable_pos();
  inline ::protos::vector* release_pos();
  inline void set_allocated_pos(::protos::vector* pos);

  // required .protos.vector vel = 9;
  inline bool has_vel() const;
  inline void clear_vel();
  static const int kVelFieldNumber = 9;
  inline const ::protos::vector& vel() const;
  inline ::protos::vector* mutable_vel();
  inline ::protos::vector* release_vel();
  inline void set_allocated_vel(::protos::vector* vel);

  // required float accel = 10;
  inline bool has_accel() const;
  inline void clear_accel();
  static const int kAccelFieldNumber = 10;
  inline float accel() const;
  inline void set_accel(float value);

  // required float pitch = 11;
  inline bool has_pitch() const;
  inline void clear_pitch();
  static const int kPitchFieldNumber = 11;
  inline float pitch() const;
  inline void set_pitch(float value);

  // required float roll = 12;
  inline bool has_roll() const;
  inline void clear_roll();
  static const int kRollFieldNumber = 12;
  inline float roll() const;
  inline void set_roll(float value);

  // required .protos.vector yaw = 13;
  inline bool has_yaw() const;
  inline void clear_yaw();
  static const int kYawFieldNumber = 13;
  inline const ::protos::vector& yaw() const;
  inline ::protos::vector* mutable_yaw();
  inline ::protos::vector* release_yaw();
  inline void set_allocated_yaw(::protos::vector* yaw);

  // optional uint32 weapon_index = 14;
  inline bool has_weapon_index() const;
  inline void clear_weapon_index();
  static const int kWeaponIndexFieldNumber = 14;
  inline ::google::protobuf::uint32 weapon_index() const;
  inline void set_weapon_index(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:protos.RenderedObj)
 private:
  inline void set_has_id();
  inline void clear_has_id();
  inline void set_has_mass();
  inline void clear_has_mass();
  inline void set_has_type();
  inline void clear_has_type();
  inline void set_has_size();
  inline void clear_has_size();
  inline void set_has_cur_tolerance();
  inline void clear_has_cur_tolerance();
  inline void set_has_max_tolerance();
  inline void clear_has_max_tolerance();
  inline void set_has_is_destroyed();
  inline void clear_has_is_destroyed();
  inline void set_has_pos();
  inline void clear_has_pos();
  inline void set_has_vel();
  inline void clear_has_vel();
  inline void set_has_accel();
  inline void clear_has_accel();
  inline void set_has_pitch();
  inline void clear_has_pitch();
  inline void set_has_roll();
  inline void clear_has_roll();
  inline void set_has_yaw();
  inline void clear_has_yaw();
  inline void set_has_weapon_index();
  inline void clear_has_weapon_index();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 id_;
  ::google::protobuf::uint32 mass_;
  ::google::protobuf::uint32 type_;
  float size_;
  float cur_tolerance_;
  float max_tolerance_;
  ::protos::vector* pos_;
  ::google::protobuf::uint32 is_destroyed_;
  float accel_;
  ::protos::vector* vel_;
  float pitch_;
  float roll_;
  ::protos::vector* yaw_;
  ::google::protobuf::uint32 weapon_index_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(14 + 31) / 32];

  friend void  protobuf_AddDesc_packetprotos_2eproto();
  friend void protobuf_AssignDesc_packetprotos_2eproto();
  friend void protobuf_ShutdownFile_packetprotos_2eproto();

  void InitAsDefaultInstance();
  static RenderedObj* default_instance_;
};
// -------------------------------------------------------------------

class Event : public ::google::protobuf::Message {
 public:
  Event();
  virtual ~Event();

  Event(const Event& from);

  inline Event& operator=(const Event& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Event& default_instance();

  void Swap(Event* other);

  // implements Message ----------------------------------------------

  Event* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Event& from);
  void MergeFrom(const Event& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 event_type = 1;
  inline bool has_event_type() const;
  inline void clear_event_type();
  static const int kEventTypeFieldNumber = 1;
  inline ::google::protobuf::uint32 event_type() const;
  inline void set_event_type(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:protos.Event)
 private:
  inline void set_has_event_type();
  inline void clear_has_event_type();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 event_type_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void  protobuf_AddDesc_packetprotos_2eproto();
  friend void protobuf_AssignDesc_packetprotos_2eproto();
  friend void protobuf_ShutdownFile_packetprotos_2eproto();

  void InitAsDefaultInstance();
  static Event* default_instance_;
};
// -------------------------------------------------------------------

class ControlInput : public ::google::protobuf::Message {
 public:
  ControlInput();
  virtual ~ControlInput();

  ControlInput(const ControlInput& from);

  inline ControlInput& operator=(const ControlInput& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ControlInput& default_instance();

  void Swap(ControlInput* other);

  // implements Message ----------------------------------------------

  ControlInput* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ControlInput& from);
  void MergeFrom(const ControlInput& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 action = 1;
  inline bool has_action() const;
  inline void clear_action();
  static const int kActionFieldNumber = 1;
  inline ::google::protobuf::uint32 action() const;
  inline void set_action(::google::protobuf::uint32 value);

  // optional float tilt = 2;
  inline bool has_tilt() const;
  inline void clear_tilt();
  static const int kTiltFieldNumber = 2;
  inline float tilt() const;
  inline void set_tilt(float value);

  // @@protoc_insertion_point(class_scope:protos.ControlInput)
 private:
  inline void set_has_action();
  inline void clear_has_action();
  inline void set_has_tilt();
  inline void clear_has_tilt();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 action_;
  float tilt_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_packetprotos_2eproto();
  friend void protobuf_AssignDesc_packetprotos_2eproto();
  friend void protobuf_ShutdownFile_packetprotos_2eproto();

  void InitAsDefaultInstance();
  static ControlInput* default_instance_;
};
// -------------------------------------------------------------------

class GeneralPacket : public ::google::protobuf::Message {
 public:
  GeneralPacket();
  virtual ~GeneralPacket();

  GeneralPacket(const GeneralPacket& from);

  inline GeneralPacket& operator=(const GeneralPacket& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const GeneralPacket& default_instance();

  void Swap(GeneralPacket* other);

  // implements Message ----------------------------------------------

  GeneralPacket* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const GeneralPacket& from);
  void MergeFrom(const GeneralPacket& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 packetType = 1;
  inline bool has_packettype() const;
  inline void clear_packettype();
  static const int kPacketTypeFieldNumber = 1;
  inline ::google::protobuf::uint32 packettype() const;
  inline void set_packettype(::google::protobuf::uint32 value);

  // optional bytes packet = 2;
  inline bool has_packet() const;
  inline void clear_packet();
  static const int kPacketFieldNumber = 2;
  inline const ::std::string& packet() const;
  inline void set_packet(const ::std::string& value);
  inline void set_packet(const char* value);
  inline void set_packet(const void* value, size_t size);
  inline ::std::string* mutable_packet();
  inline ::std::string* release_packet();
  inline void set_allocated_packet(::std::string* packet);

  // optional string packetId = 3;
  inline bool has_packetid() const;
  inline void clear_packetid();
  static const int kPacketIdFieldNumber = 3;
  inline const ::std::string& packetid() const;
  inline void set_packetid(const ::std::string& value);
  inline void set_packetid(const char* value);
  inline void set_packetid(const char* value, size_t size);
  inline ::std::string* mutable_packetid();
  inline ::std::string* release_packetid();
  inline void set_allocated_packetid(::std::string* packetid);

  // @@protoc_insertion_point(class_scope:protos.GeneralPacket)
 private:
  inline void set_has_packettype();
  inline void clear_has_packettype();
  inline void set_has_packet();
  inline void clear_has_packet();
  inline void set_has_packetid();
  inline void clear_has_packetid();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* packet_;
  ::std::string* packetid_;
  ::google::protobuf::uint32 packettype_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  friend void  protobuf_AddDesc_packetprotos_2eproto();
  friend void protobuf_AssignDesc_packetprotos_2eproto();
  friend void protobuf_ShutdownFile_packetprotos_2eproto();

  void InitAsDefaultInstance();
  static GeneralPacket* default_instance_;
};
// -------------------------------------------------------------------

class ShipInitPacket : public ::google::protobuf::Message {
 public:
  ShipInitPacket();
  virtual ~ShipInitPacket();

  ShipInitPacket(const ShipInitPacket& from);

  inline ShipInitPacket& operator=(const ShipInitPacket& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ShipInitPacket& default_instance();

  void Swap(ShipInitPacket* other);

  // implements Message ----------------------------------------------

  ShipInitPacket* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ShipInitPacket& from);
  void MergeFrom(const ShipInitPacket& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .protos.RenderedObj ship = 1;
  inline bool has_ship() const;
  inline void clear_ship();
  static const int kShipFieldNumber = 1;
  inline const ::protos::RenderedObj& ship() const;
  inline ::protos::RenderedObj* mutable_ship();
  inline ::protos::RenderedObj* release_ship();
  inline void set_allocated_ship(::protos::RenderedObj* ship);

  // @@protoc_insertion_point(class_scope:protos.ShipInitPacket)
 private:
  inline void set_has_ship();
  inline void clear_has_ship();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::protos::RenderedObj* ship_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void  protobuf_AddDesc_packetprotos_2eproto();
  friend void protobuf_AssignDesc_packetprotos_2eproto();
  friend void protobuf_ShutdownFile_packetprotos_2eproto();

  void InitAsDefaultInstance();
  static ShipInitPacket* default_instance_;
};
// -------------------------------------------------------------------

class ObjsAndEventsPacket : public ::google::protobuf::Message {
 public:
  ObjsAndEventsPacket();
  virtual ~ObjsAndEventsPacket();

  ObjsAndEventsPacket(const ObjsAndEventsPacket& from);

  inline ObjsAndEventsPacket& operator=(const ObjsAndEventsPacket& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ObjsAndEventsPacket& default_instance();

  void Swap(ObjsAndEventsPacket* other);

  // implements Message ----------------------------------------------

  ObjsAndEventsPacket* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ObjsAndEventsPacket& from);
  void MergeFrom(const ObjsAndEventsPacket& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .protos.RenderedObj obj = 1;
  inline int obj_size() const;
  inline void clear_obj();
  static const int kObjFieldNumber = 1;
  inline const ::protos::RenderedObj& obj(int index) const;
  inline ::protos::RenderedObj* mutable_obj(int index);
  inline ::protos::RenderedObj* add_obj();
  inline const ::google::protobuf::RepeatedPtrField< ::protos::RenderedObj >&
      obj() const;
  inline ::google::protobuf::RepeatedPtrField< ::protos::RenderedObj >*
      mutable_obj();

  // repeated .protos.Event event = 2;
  inline int event_size() const;
  inline void clear_event();
  static const int kEventFieldNumber = 2;
  inline const ::protos::Event& event(int index) const;
  inline ::protos::Event* mutable_event(int index);
  inline ::protos::Event* add_event();
  inline const ::google::protobuf::RepeatedPtrField< ::protos::Event >&
      event() const;
  inline ::google::protobuf::RepeatedPtrField< ::protos::Event >*
      mutable_event();

  // @@protoc_insertion_point(class_scope:protos.ObjsAndEventsPacket)
 private:

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::RepeatedPtrField< ::protos::RenderedObj > obj_;
  ::google::protobuf::RepeatedPtrField< ::protos::Event > event_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_packetprotos_2eproto();
  friend void protobuf_AssignDesc_packetprotos_2eproto();
  friend void protobuf_ShutdownFile_packetprotos_2eproto();

  void InitAsDefaultInstance();
  static ObjsAndEventsPacket* default_instance_;
};
// -------------------------------------------------------------------

class ObjsAndEventsReqPacket : public ::google::protobuf::Message {
 public:
  ObjsAndEventsReqPacket();
  virtual ~ObjsAndEventsReqPacket();

  ObjsAndEventsReqPacket(const ObjsAndEventsReqPacket& from);

  inline ObjsAndEventsReqPacket& operator=(const ObjsAndEventsReqPacket& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ObjsAndEventsReqPacket& default_instance();

  void Swap(ObjsAndEventsReqPacket* other);

  // implements Message ----------------------------------------------

  ObjsAndEventsReqPacket* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ObjsAndEventsReqPacket& from);
  void MergeFrom(const ObjsAndEventsReqPacket& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 req = 1;
  inline bool has_req() const;
  inline void clear_req();
  static const int kReqFieldNumber = 1;
  inline ::google::protobuf::uint32 req() const;
  inline void set_req(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:protos.ObjsAndEventsReqPacket)
 private:
  inline void set_has_req();
  inline void clear_has_req();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 req_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void  protobuf_AddDesc_packetprotos_2eproto();
  friend void protobuf_AssignDesc_packetprotos_2eproto();
  friend void protobuf_ShutdownFile_packetprotos_2eproto();

  void InitAsDefaultInstance();
  static ObjsAndEventsReqPacket* default_instance_;
};
// -------------------------------------------------------------------

class EventAckPacket : public ::google::protobuf::Message {
 public:
  EventAckPacket();
  virtual ~EventAckPacket();

  EventAckPacket(const EventAckPacket& from);

  inline EventAckPacket& operator=(const EventAckPacket& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const EventAckPacket& default_instance();

  void Swap(EventAckPacket* other);

  // implements Message ----------------------------------------------

  EventAckPacket* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const EventAckPacket& from);
  void MergeFrom(const EventAckPacket& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 ack = 1;
  inline bool has_ack() const;
  inline void clear_ack();
  static const int kAckFieldNumber = 1;
  inline ::google::protobuf::uint32 ack() const;
  inline void set_ack(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:protos.EventAckPacket)
 private:
  inline void set_has_ack();
  inline void clear_has_ack();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 ack_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void  protobuf_AddDesc_packetprotos_2eproto();
  friend void protobuf_AssignDesc_packetprotos_2eproto();
  friend void protobuf_ShutdownFile_packetprotos_2eproto();

  void InitAsDefaultInstance();
  static EventAckPacket* default_instance_;
};
// -------------------------------------------------------------------

class ControlInputPacket : public ::google::protobuf::Message {
 public:
  ControlInputPacket();
  virtual ~ControlInputPacket();

  ControlInputPacket(const ControlInputPacket& from);

  inline ControlInputPacket& operator=(const ControlInputPacket& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ControlInputPacket& default_instance();

  void Swap(ControlInputPacket* other);

  // implements Message ----------------------------------------------

  ControlInputPacket* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ControlInputPacket& from);
  void MergeFrom(const ControlInputPacket& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .protos.ControlInput control = 1;
  inline bool has_control() const;
  inline void clear_control();
  static const int kControlFieldNumber = 1;
  inline const ::protos::ControlInput& control() const;
  inline ::protos::ControlInput* mutable_control();
  inline ::protos::ControlInput* release_control();
  inline void set_allocated_control(::protos::ControlInput* control);

  // @@protoc_insertion_point(class_scope:protos.ControlInputPacket)
 private:
  inline void set_has_control();
  inline void clear_has_control();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::protos::ControlInput* control_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void  protobuf_AddDesc_packetprotos_2eproto();
  friend void protobuf_AssignDesc_packetprotos_2eproto();
  friend void protobuf_ShutdownFile_packetprotos_2eproto();

  void InitAsDefaultInstance();
  static ControlInputPacket* default_instance_;
};
// ===================================================================


// ===================================================================

// vector

// required float x = 1;
inline bool vector::has_x() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void vector::set_has_x() {
  _has_bits_[0] |= 0x00000001u;
}
inline void vector::clear_has_x() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void vector::clear_x() {
  x_ = 0;
  clear_has_x();
}
inline float vector::x() const {
  return x_;
}
inline void vector::set_x(float value) {
  set_has_x();
  x_ = value;
}

// required float y = 2;
inline bool vector::has_y() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void vector::set_has_y() {
  _has_bits_[0] |= 0x00000002u;
}
inline void vector::clear_has_y() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void vector::clear_y() {
  y_ = 0;
  clear_has_y();
}
inline float vector::y() const {
  return y_;
}
inline void vector::set_y(float value) {
  set_has_y();
  y_ = value;
}

// required float z = 3;
inline bool vector::has_z() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void vector::set_has_z() {
  _has_bits_[0] |= 0x00000004u;
}
inline void vector::clear_has_z() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void vector::clear_z() {
  z_ = 0;
  clear_has_z();
}
inline float vector::z() const {
  return z_;
}
inline void vector::set_z(float value) {
  set_has_z();
  z_ = value;
}

// -------------------------------------------------------------------

// RenderedObj

// required uint32 id = 1;
inline bool RenderedObj::has_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void RenderedObj::set_has_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void RenderedObj::clear_has_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void RenderedObj::clear_id() {
  id_ = 0u;
  clear_has_id();
}
inline ::google::protobuf::uint32 RenderedObj::id() const {
  return id_;
}
inline void RenderedObj::set_id(::google::protobuf::uint32 value) {
  set_has_id();
  id_ = value;
}

// required uint32 mass = 2;
inline bool RenderedObj::has_mass() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void RenderedObj::set_has_mass() {
  _has_bits_[0] |= 0x00000002u;
}
inline void RenderedObj::clear_has_mass() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void RenderedObj::clear_mass() {
  mass_ = 0u;
  clear_has_mass();
}
inline ::google::protobuf::uint32 RenderedObj::mass() const {
  return mass_;
}
inline void RenderedObj::set_mass(::google::protobuf::uint32 value) {
  set_has_mass();
  mass_ = value;
}

// required uint32 type = 3;
inline bool RenderedObj::has_type() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void RenderedObj::set_has_type() {
  _has_bits_[0] |= 0x00000004u;
}
inline void RenderedObj::clear_has_type() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void RenderedObj::clear_type() {
  type_ = 0u;
  clear_has_type();
}
inline ::google::protobuf::uint32 RenderedObj::type() const {
  return type_;
}
inline void RenderedObj::set_type(::google::protobuf::uint32 value) {
  set_has_type();
  type_ = value;
}

// required float size = 4;
inline bool RenderedObj::has_size() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void RenderedObj::set_has_size() {
  _has_bits_[0] |= 0x00000008u;
}
inline void RenderedObj::clear_has_size() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void RenderedObj::clear_size() {
  size_ = 0;
  clear_has_size();
}
inline float RenderedObj::size() const {
  return size_;
}
inline void RenderedObj::set_size(float value) {
  set_has_size();
  size_ = value;
}

// required float cur_tolerance = 5;
inline bool RenderedObj::has_cur_tolerance() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void RenderedObj::set_has_cur_tolerance() {
  _has_bits_[0] |= 0x00000010u;
}
inline void RenderedObj::clear_has_cur_tolerance() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void RenderedObj::clear_cur_tolerance() {
  cur_tolerance_ = 0;
  clear_has_cur_tolerance();
}
inline float RenderedObj::cur_tolerance() const {
  return cur_tolerance_;
}
inline void RenderedObj::set_cur_tolerance(float value) {
  set_has_cur_tolerance();
  cur_tolerance_ = value;
}

// required float max_tolerance = 6;
inline bool RenderedObj::has_max_tolerance() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void RenderedObj::set_has_max_tolerance() {
  _has_bits_[0] |= 0x00000020u;
}
inline void RenderedObj::clear_has_max_tolerance() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void RenderedObj::clear_max_tolerance() {
  max_tolerance_ = 0;
  clear_has_max_tolerance();
}
inline float RenderedObj::max_tolerance() const {
  return max_tolerance_;
}
inline void RenderedObj::set_max_tolerance(float value) {
  set_has_max_tolerance();
  max_tolerance_ = value;
}

// required uint32 is_destroyed = 7;
inline bool RenderedObj::has_is_destroyed() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void RenderedObj::set_has_is_destroyed() {
  _has_bits_[0] |= 0x00000040u;
}
inline void RenderedObj::clear_has_is_destroyed() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void RenderedObj::clear_is_destroyed() {
  is_destroyed_ = 0u;
  clear_has_is_destroyed();
}
inline ::google::protobuf::uint32 RenderedObj::is_destroyed() const {
  return is_destroyed_;
}
inline void RenderedObj::set_is_destroyed(::google::protobuf::uint32 value) {
  set_has_is_destroyed();
  is_destroyed_ = value;
}

// required .protos.vector pos = 8;
inline bool RenderedObj::has_pos() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void RenderedObj::set_has_pos() {
  _has_bits_[0] |= 0x00000080u;
}
inline void RenderedObj::clear_has_pos() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void RenderedObj::clear_pos() {
  if (pos_ != NULL) pos_->::protos::vector::Clear();
  clear_has_pos();
}
inline const ::protos::vector& RenderedObj::pos() const {
  return pos_ != NULL ? *pos_ : *default_instance_->pos_;
}
inline ::protos::vector* RenderedObj::mutable_pos() {
  set_has_pos();
  if (pos_ == NULL) pos_ = new ::protos::vector;
  return pos_;
}
inline ::protos::vector* RenderedObj::release_pos() {
  clear_has_pos();
  ::protos::vector* temp = pos_;
  pos_ = NULL;
  return temp;
}
inline void RenderedObj::set_allocated_pos(::protos::vector* pos) {
  delete pos_;
  pos_ = pos;
  if (pos) {
    set_has_pos();
  } else {
    clear_has_pos();
  }
}

// required .protos.vector vel = 9;
inline bool RenderedObj::has_vel() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void RenderedObj::set_has_vel() {
  _has_bits_[0] |= 0x00000100u;
}
inline void RenderedObj::clear_has_vel() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void RenderedObj::clear_vel() {
  if (vel_ != NULL) vel_->::protos::vector::Clear();
  clear_has_vel();
}
inline const ::protos::vector& RenderedObj::vel() const {
  return vel_ != NULL ? *vel_ : *default_instance_->vel_;
}
inline ::protos::vector* RenderedObj::mutable_vel() {
  set_has_vel();
  if (vel_ == NULL) vel_ = new ::protos::vector;
  return vel_;
}
inline ::protos::vector* RenderedObj::release_vel() {
  clear_has_vel();
  ::protos::vector* temp = vel_;
  vel_ = NULL;
  return temp;
}
inline void RenderedObj::set_allocated_vel(::protos::vector* vel) {
  delete vel_;
  vel_ = vel;
  if (vel) {
    set_has_vel();
  } else {
    clear_has_vel();
  }
}

// required float accel = 10;
inline bool RenderedObj::has_accel() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void RenderedObj::set_has_accel() {
  _has_bits_[0] |= 0x00000200u;
}
inline void RenderedObj::clear_has_accel() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void RenderedObj::clear_accel() {
  accel_ = 0;
  clear_has_accel();
}
inline float RenderedObj::accel() const {
  return accel_;
}
inline void RenderedObj::set_accel(float value) {
  set_has_accel();
  accel_ = value;
}

// required float pitch = 11;
inline bool RenderedObj::has_pitch() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
inline void RenderedObj::set_has_pitch() {
  _has_bits_[0] |= 0x00000400u;
}
inline void RenderedObj::clear_has_pitch() {
  _has_bits_[0] &= ~0x00000400u;
}
inline void RenderedObj::clear_pitch() {
  pitch_ = 0;
  clear_has_pitch();
}
inline float RenderedObj::pitch() const {
  return pitch_;
}
inline void RenderedObj::set_pitch(float value) {
  set_has_pitch();
  pitch_ = value;
}

// required float roll = 12;
inline bool RenderedObj::has_roll() const {
  return (_has_bits_[0] & 0x00000800u) != 0;
}
inline void RenderedObj::set_has_roll() {
  _has_bits_[0] |= 0x00000800u;
}
inline void RenderedObj::clear_has_roll() {
  _has_bits_[0] &= ~0x00000800u;
}
inline void RenderedObj::clear_roll() {
  roll_ = 0;
  clear_has_roll();
}
inline float RenderedObj::roll() const {
  return roll_;
}
inline void RenderedObj::set_roll(float value) {
  set_has_roll();
  roll_ = value;
}

// required .protos.vector yaw = 13;
inline bool RenderedObj::has_yaw() const {
  return (_has_bits_[0] & 0x00001000u) != 0;
}
inline void RenderedObj::set_has_yaw() {
  _has_bits_[0] |= 0x00001000u;
}
inline void RenderedObj::clear_has_yaw() {
  _has_bits_[0] &= ~0x00001000u;
}
inline void RenderedObj::clear_yaw() {
  if (yaw_ != NULL) yaw_->::protos::vector::Clear();
  clear_has_yaw();
}
inline const ::protos::vector& RenderedObj::yaw() const {
  return yaw_ != NULL ? *yaw_ : *default_instance_->yaw_;
}
inline ::protos::vector* RenderedObj::mutable_yaw() {
  set_has_yaw();
  if (yaw_ == NULL) yaw_ = new ::protos::vector;
  return yaw_;
}
inline ::protos::vector* RenderedObj::release_yaw() {
  clear_has_yaw();
  ::protos::vector* temp = yaw_;
  yaw_ = NULL;
  return temp;
}
inline void RenderedObj::set_allocated_yaw(::protos::vector* yaw) {
  delete yaw_;
  yaw_ = yaw;
  if (yaw) {
    set_has_yaw();
  } else {
    clear_has_yaw();
  }
}

// optional uint32 weapon_index = 14;
inline bool RenderedObj::has_weapon_index() const {
  return (_has_bits_[0] & 0x00002000u) != 0;
}
inline void RenderedObj::set_has_weapon_index() {
  _has_bits_[0] |= 0x00002000u;
}
inline void RenderedObj::clear_has_weapon_index() {
  _has_bits_[0] &= ~0x00002000u;
}
inline void RenderedObj::clear_weapon_index() {
  weapon_index_ = 0u;
  clear_has_weapon_index();
}
inline ::google::protobuf::uint32 RenderedObj::weapon_index() const {
  return weapon_index_;
}
inline void RenderedObj::set_weapon_index(::google::protobuf::uint32 value) {
  set_has_weapon_index();
  weapon_index_ = value;
}

// -------------------------------------------------------------------

// Event

// required uint32 event_type = 1;
inline bool Event::has_event_type() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Event::set_has_event_type() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Event::clear_has_event_type() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Event::clear_event_type() {
  event_type_ = 0u;
  clear_has_event_type();
}
inline ::google::protobuf::uint32 Event::event_type() const {
  return event_type_;
}
inline void Event::set_event_type(::google::protobuf::uint32 value) {
  set_has_event_type();
  event_type_ = value;
}

// -------------------------------------------------------------------

// ControlInput

// required uint32 action = 1;
inline bool ControlInput::has_action() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ControlInput::set_has_action() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ControlInput::clear_has_action() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ControlInput::clear_action() {
  action_ = 0u;
  clear_has_action();
}
inline ::google::protobuf::uint32 ControlInput::action() const {
  return action_;
}
inline void ControlInput::set_action(::google::protobuf::uint32 value) {
  set_has_action();
  action_ = value;
}

// optional float tilt = 2;
inline bool ControlInput::has_tilt() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ControlInput::set_has_tilt() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ControlInput::clear_has_tilt() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ControlInput::clear_tilt() {
  tilt_ = 0;
  clear_has_tilt();
}
inline float ControlInput::tilt() const {
  return tilt_;
}
inline void ControlInput::set_tilt(float value) {
  set_has_tilt();
  tilt_ = value;
}

// -------------------------------------------------------------------

// GeneralPacket

// required uint32 packetType = 1;
inline bool GeneralPacket::has_packettype() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void GeneralPacket::set_has_packettype() {
  _has_bits_[0] |= 0x00000001u;
}
inline void GeneralPacket::clear_has_packettype() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void GeneralPacket::clear_packettype() {
  packettype_ = 0u;
  clear_has_packettype();
}
inline ::google::protobuf::uint32 GeneralPacket::packettype() const {
  return packettype_;
}
inline void GeneralPacket::set_packettype(::google::protobuf::uint32 value) {
  set_has_packettype();
  packettype_ = value;
}

// optional bytes packet = 2;
inline bool GeneralPacket::has_packet() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void GeneralPacket::set_has_packet() {
  _has_bits_[0] |= 0x00000002u;
}
inline void GeneralPacket::clear_has_packet() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void GeneralPacket::clear_packet() {
  if (packet_ != &::google::protobuf::internal::kEmptyString) {
    packet_->clear();
  }
  clear_has_packet();
}
inline const ::std::string& GeneralPacket::packet() const {
  return *packet_;
}
inline void GeneralPacket::set_packet(const ::std::string& value) {
  set_has_packet();
  if (packet_ == &::google::protobuf::internal::kEmptyString) {
    packet_ = new ::std::string;
  }
  packet_->assign(value);
}
inline void GeneralPacket::set_packet(const char* value) {
  set_has_packet();
  if (packet_ == &::google::protobuf::internal::kEmptyString) {
    packet_ = new ::std::string;
  }
  packet_->assign(value);
}
inline void GeneralPacket::set_packet(const void* value, size_t size) {
  set_has_packet();
  if (packet_ == &::google::protobuf::internal::kEmptyString) {
    packet_ = new ::std::string;
  }
  packet_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* GeneralPacket::mutable_packet() {
  set_has_packet();
  if (packet_ == &::google::protobuf::internal::kEmptyString) {
    packet_ = new ::std::string;
  }
  return packet_;
}
inline ::std::string* GeneralPacket::release_packet() {
  clear_has_packet();
  if (packet_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = packet_;
    packet_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void GeneralPacket::set_allocated_packet(::std::string* packet) {
  if (packet_ != &::google::protobuf::internal::kEmptyString) {
    delete packet_;
  }
  if (packet) {
    set_has_packet();
    packet_ = packet;
  } else {
    clear_has_packet();
    packet_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string packetId = 3;
inline bool GeneralPacket::has_packetid() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void GeneralPacket::set_has_packetid() {
  _has_bits_[0] |= 0x00000004u;
}
inline void GeneralPacket::clear_has_packetid() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void GeneralPacket::clear_packetid() {
  if (packetid_ != &::google::protobuf::internal::kEmptyString) {
    packetid_->clear();
  }
  clear_has_packetid();
}
inline const ::std::string& GeneralPacket::packetid() const {
  return *packetid_;
}
inline void GeneralPacket::set_packetid(const ::std::string& value) {
  set_has_packetid();
  if (packetid_ == &::google::protobuf::internal::kEmptyString) {
    packetid_ = new ::std::string;
  }
  packetid_->assign(value);
}
inline void GeneralPacket::set_packetid(const char* value) {
  set_has_packetid();
  if (packetid_ == &::google::protobuf::internal::kEmptyString) {
    packetid_ = new ::std::string;
  }
  packetid_->assign(value);
}
inline void GeneralPacket::set_packetid(const char* value, size_t size) {
  set_has_packetid();
  if (packetid_ == &::google::protobuf::internal::kEmptyString) {
    packetid_ = new ::std::string;
  }
  packetid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* GeneralPacket::mutable_packetid() {
  set_has_packetid();
  if (packetid_ == &::google::protobuf::internal::kEmptyString) {
    packetid_ = new ::std::string;
  }
  return packetid_;
}
inline ::std::string* GeneralPacket::release_packetid() {
  clear_has_packetid();
  if (packetid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = packetid_;
    packetid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void GeneralPacket::set_allocated_packetid(::std::string* packetid) {
  if (packetid_ != &::google::protobuf::internal::kEmptyString) {
    delete packetid_;
  }
  if (packetid) {
    set_has_packetid();
    packetid_ = packetid;
  } else {
    clear_has_packetid();
    packetid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// ShipInitPacket

// required .protos.RenderedObj ship = 1;
inline bool ShipInitPacket::has_ship() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ShipInitPacket::set_has_ship() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ShipInitPacket::clear_has_ship() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ShipInitPacket::clear_ship() {
  if (ship_ != NULL) ship_->::protos::RenderedObj::Clear();
  clear_has_ship();
}
inline const ::protos::RenderedObj& ShipInitPacket::ship() const {
  return ship_ != NULL ? *ship_ : *default_instance_->ship_;
}
inline ::protos::RenderedObj* ShipInitPacket::mutable_ship() {
  set_has_ship();
  if (ship_ == NULL) ship_ = new ::protos::RenderedObj;
  return ship_;
}
inline ::protos::RenderedObj* ShipInitPacket::release_ship() {
  clear_has_ship();
  ::protos::RenderedObj* temp = ship_;
  ship_ = NULL;
  return temp;
}
inline void ShipInitPacket::set_allocated_ship(::protos::RenderedObj* ship) {
  delete ship_;
  ship_ = ship;
  if (ship) {
    set_has_ship();
  } else {
    clear_has_ship();
  }
}

// -------------------------------------------------------------------

// ObjsAndEventsPacket

// repeated .protos.RenderedObj obj = 1;
inline int ObjsAndEventsPacket::obj_size() const {
  return obj_.size();
}
inline void ObjsAndEventsPacket::clear_obj() {
  obj_.Clear();
}
inline const ::protos::RenderedObj& ObjsAndEventsPacket::obj(int index) const {
  return obj_.Get(index);
}
inline ::protos::RenderedObj* ObjsAndEventsPacket::mutable_obj(int index) {
  return obj_.Mutable(index);
}
inline ::protos::RenderedObj* ObjsAndEventsPacket::add_obj() {
  return obj_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::protos::RenderedObj >&
ObjsAndEventsPacket::obj() const {
  return obj_;
}
inline ::google::protobuf::RepeatedPtrField< ::protos::RenderedObj >*
ObjsAndEventsPacket::mutable_obj() {
  return &obj_;
}

// repeated .protos.Event event = 2;
inline int ObjsAndEventsPacket::event_size() const {
  return event_.size();
}
inline void ObjsAndEventsPacket::clear_event() {
  event_.Clear();
}
inline const ::protos::Event& ObjsAndEventsPacket::event(int index) const {
  return event_.Get(index);
}
inline ::protos::Event* ObjsAndEventsPacket::mutable_event(int index) {
  return event_.Mutable(index);
}
inline ::protos::Event* ObjsAndEventsPacket::add_event() {
  return event_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::protos::Event >&
ObjsAndEventsPacket::event() const {
  return event_;
}
inline ::google::protobuf::RepeatedPtrField< ::protos::Event >*
ObjsAndEventsPacket::mutable_event() {
  return &event_;
}

// -------------------------------------------------------------------

// ObjsAndEventsReqPacket

// required uint32 req = 1;
inline bool ObjsAndEventsReqPacket::has_req() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ObjsAndEventsReqPacket::set_has_req() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ObjsAndEventsReqPacket::clear_has_req() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ObjsAndEventsReqPacket::clear_req() {
  req_ = 0u;
  clear_has_req();
}
inline ::google::protobuf::uint32 ObjsAndEventsReqPacket::req() const {
  return req_;
}
inline void ObjsAndEventsReqPacket::set_req(::google::protobuf::uint32 value) {
  set_has_req();
  req_ = value;
}

// -------------------------------------------------------------------

// EventAckPacket

// required uint32 ack = 1;
inline bool EventAckPacket::has_ack() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void EventAckPacket::set_has_ack() {
  _has_bits_[0] |= 0x00000001u;
}
inline void EventAckPacket::clear_has_ack() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void EventAckPacket::clear_ack() {
  ack_ = 0u;
  clear_has_ack();
}
inline ::google::protobuf::uint32 EventAckPacket::ack() const {
  return ack_;
}
inline void EventAckPacket::set_ack(::google::protobuf::uint32 value) {
  set_has_ack();
  ack_ = value;
}

// -------------------------------------------------------------------

// ControlInputPacket

// required .protos.ControlInput control = 1;
inline bool ControlInputPacket::has_control() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ControlInputPacket::set_has_control() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ControlInputPacket::clear_has_control() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ControlInputPacket::clear_control() {
  if (control_ != NULL) control_->::protos::ControlInput::Clear();
  clear_has_control();
}
inline const ::protos::ControlInput& ControlInputPacket::control() const {
  return control_ != NULL ? *control_ : *default_instance_->control_;
}
inline ::protos::ControlInput* ControlInputPacket::mutable_control() {
  set_has_control();
  if (control_ == NULL) control_ = new ::protos::ControlInput;
  return control_;
}
inline ::protos::ControlInput* ControlInputPacket::release_control() {
  clear_has_control();
  ::protos::ControlInput* temp = control_;
  control_ = NULL;
  return temp;
}
inline void ControlInputPacket::set_allocated_control(::protos::ControlInput* control) {
  delete control_;
  control_ = control;
  if (control) {
    set_has_control();
  } else {
    clear_has_control();
  }
}


// @@protoc_insertion_point(namespace_scope)

}  // namespace protos

#ifndef SWIG
namespace google {
namespace protobuf {


}  // namespace google
}  // namespace protobuf
#endif  // SWIG

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_packetprotos_2eproto__INCLUDED
